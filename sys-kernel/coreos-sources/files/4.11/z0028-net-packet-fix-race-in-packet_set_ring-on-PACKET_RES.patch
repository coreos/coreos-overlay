From 8dc87df9a5f7b42f5ddd738b02c8e76161bdcfc5 Mon Sep 17 00:00:00 2001
From: Willem de Bruijn <willemdebruijn.kernel@gmail.com>
Date: Fri, 4 Aug 2017 12:48:20 -0400
Subject: [PATCH 28/28] net-packet: fix race in packet_set_ring on
 PACKET_RESERVE

PACKET_RESERVE reserves headroom in memory mapped packet ring frames.
The value po->tp_reserve must is verified to be safe in packet_set_ring

    if (unlikely(req->tp_frame_size < po->tp_hdrlen + po->tp_reserve))

and the setsockopt fails once a ring is set.

    if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
            return -EBUSY;

This operation does not take the socket lock. This leads to a race
similar to the one with PACKET_VERSION fixed in commit 84ac7260236a
("packet: fix race condition in packet_set_ring").

Fix this issue in the same manner: take the socket lock, which as of
that patch is held for the duration of packet_set_ring.

This bug was discovered with syzkaller.

Reported-by: Andrey Konovalov <andreyknvl@google.com>
CVE: CVE-2017-1000111
Signed-off-by: Willem de Bruijn <willemb@google.com>
---
 net/packet/af_packet.c | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index b2d8e8c23e46..6be19af61b6e 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -3661,14 +3661,19 @@ packet_setsockopt(struct socket *sock, int level, int optname, char __user *optv
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
-		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
-			return -EBUSY;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 		if (val > INT_MAX)
 			return -EINVAL;
-		po->tp_reserve = val;
-		return 0;
+		lock_sock(sk);
+		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
+			ret = -EBUSY;
+		else {
+			po->tp_reserve = val;
+			ret = 0;
+		}
+		release_sock(sk);
+		return ret;
 	}
 	case PACKET_LOSS:
 	{
-- 
2.13.0

